> 字符流转，就此谱写逻辑华章

# 概述

在本学期的编译实验中，我实现了一个简单的编译器，支持将SysY语义编译为MIPS汇编，并进行一些效果还不错的优化。

编译器的实现参考了理论课中给出的五级架构，即：

1. 词法分析：将源程序解析为token序列，并在此过程中进行代码的错误检查，是否有明显的词法错误

2. 语法分析：在token流基础上构建抽象语法树，并在此过程中识别源程序中的不合理成分

3. 语义分析、中间代码生成：基于语法分析得到的抽象语法树，将语法树转换为中间代码形式，同时在这个过程中识别一部分语义问题、符号问题，实现程序的初始架构

   此外，中间代码采用了LLVM，基于其value-use框架搭建了程序内部的依赖关系

4. 代码优化：实现了一些典型的代码优化，如：mem2reg、寄存器分配，LVN、死代码删除、公共子表达式删除、乘除法优化等，实现了较好的效果

5. 生成目标代码：将LLVM-IR转换为MIPS代码，并进行寄存器分配，得到可在目标体系结构上运行的MIPS汇编代码

编译器的整体代码结构为：

```
.
├─backend
│  └─mips
│      └─assembly
│          ├─data
│          └─fake
├─error
├─frontend
│  ├─ast
│  │  ├─block
│  │  ├─decl
│  │  ├─exp
│  │  │  └─recursion
│  │  ├─func
│  │  ├─stmt
│  │  ├─token
│  │  └─value
│  ├─lexer
│  └─parser
├─META-INF
├─midend
│  ├─llvm
│  │  ├─constant
│  │  ├─instr
│  │  │  ├─io
│  │  │  └─phi
│  │  ├─type
│  │  ├─use
│  │  └─value
│  ├─symbol
│  └─visit
├─optimize
└─utils
```

编译器的架构遵循的较为规整的前后端分离架构，具备良好的可扩展性。

# 架构概述

在整体的构建中，我将编译器分为了前中后三段，并设计了错误处理端。在编译器的运行中，在每一端各司其职，仅能通过顶层的端级进行交互，达到了“高内聚，低耦合”的效果。

同时，在编译器的书写中，我还尽量运用了多种面向对象设计思想，融入了多种复杂设计模式，使得编译器的整体书写较为优雅，具有良好的阅读效果。

## 整体概述

整理以`Compiler`类为入口，并封装了`Frontend`、`Midend`、`Backend`三个模块，不同端的交互只能通过与另一端的静态方法进行交互，达成了良好的封装效果。同时，还封装了`ErrorRecorder`类，用于记录编译过程中出现的错误，并进行错误信息的输出。

### 三端分离的设计架构

在我的设计中，前中后三端设计为了静态类，提供了进行交互的静态方法，不暴露内部的接口。

| 方法                | 所属端 | 作用               |
| ------------------- | ------ | ------------------ |
| SetInput            | 前端   | 设置相应的文件输入 |
| GenerateTokenList   | 前端   | 生成token序列      |
| GenerateAstTree     | 前端   | 生成抽象语法树     |
| GetTokenList        | 前端   | 获取token序列      |
| GetAstTree          | 前端   | 获取抽象语法树     |
| GenerateSymbolTable | 中端   | 生成符号表         |
| GenerateIr          | 中端   | 生成中间代码IR     |
| GetSymbolTable      | 中端   | 获取符号表         |
| GetIrModule         | 中端   | 获取IR-module      |
| GenerateMips        | 后端   | 生成mips目标代码   |
| GetMipsModule       | 后端   | 获取mips-module    |

### 输入输出封装

为了统一程序的IO操作，设计了`IOhandler`类，进行输出要求的相关信息，包括中间代码IR、mips目标代码等。与原先的数据生成进行解耦合。

同时，重写了核心module的`toString()`方法，使得调用更加自然。

### 静态方法封装

对于封装的每个类，为了减少不必要的函数调用开销，同时在编译器执行过程中大部分**宏观操作**都是确定的，我使用静态方法代替了常见的单例模式进行执行。

这样的好处是显而易见的：在程序的执行过程中函数调用更为简洁优雅，只需要指定类名即可调用相关的方法，在逻辑上也更加自然清洗。这样也客观存在着一些坏处：如方法全局化，静态方法调用的传播特性使得复杂类的静态方法数量激增。不过在衡量取舍后，我觉得这是可以接受的。

### moudle-builder分离的生产架构

对于每一段，都使用了module+builder的设计思想，将数据生成和数据储存进行分离。

module是实际需要构建的对象，如llvm-module，mips-module等，其并不直接参与其内部储存数据的生成，而是仅负责数据的储存。具体的数据储存全部交给具体的builder进行。

这样进行设计的好处有：

1. 降低了module类的复杂性：无需处理过多的外界输入信息，不需要参与外界数据繁杂的处理，能够对复杂性进行屏蔽，实现良好的封装效果
2. 为扩展性保留空间：尽管实现一个编译器是固定的任务，并不存在着扩展任务，但是依然处于象牙塔中，总要为知识的幻想留下空间：可能的多文件编译，支持的多种后端体系结构等等。将数据的生产和储存进行分离，可以更高地留下扩展空间
3. 更有利于前中后三端架构：在每一端中，可以只储存相应的module，而无需应对数据生成的冗余逻辑和数据结构，更好地有利于高内聚低耦合的设计目标

## 前端

前端的作用是处理与源程序有关的部分，即处理源文件输入，生成token序列，再基于token序列进行语法分析，生成抽象语法树。

对此我封装了`Lexer`和`Parser`两个类用于前端的 相关操作，整体不直接进行数据传递和方法交互，而是通过`Frontend`这一前端







# 词法分析

词法分析属于前端的解析部分

# 语法分析



# 语义分析



# 错误处理



# 中间代码生成



# 目标代码生成



# 代码优化









# 参考与感谢

在编译器的书写过程中，已有的成熟编译器、往届同学的编译器都给了我很多灵感，在此一并感谢！

文档参考：

1. LLVM官方文档：https://llvm.org/docs/
2. LLVM框架参考：https://github.com/Hyggge/Petrichor
3. 优化框架参考：https://github.com/Thysrael/Pansy
4. 乘除法优化参考：https://github.com/CajZella/Compiler

感谢：

1. 静谧的夜晚，写完了大部分编译代码
2. 清冷的月光，抚平了时而的迷茫焦虑
3. 愚笨的我，卒终有所获

在编译器的书写过程中，还有许多的感想与感概，更多的就留到感想文档吧！